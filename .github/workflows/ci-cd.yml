name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false  # Queue instead of canceling

env:
  NODE_VERSION: '20'
  DOTNET_VERSION: '9.0.x'

jobs:
  # Build jobs run in parallel
  # ICP jobs commented out - ICP canisters need deployment to network, not just build
  # See apps/icp/README.md for manual deployment instructions
  backend:
    name: Build Backend
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore dependencies
      run: dotnet restore apps/backend/TreffServices.sln
    
    - name: Build
      run: dotnet build apps/backend/TreffServices.sln --no-restore --configuration Release
    
    - name: Test
      run: dotnet test apps/backend/TreffServices.sln --no-build --configuration Release --verbosity normal

  frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build frontend
      run: npm run build --workspace=apps/frontend
      env:
        CI: false  # Don't treat warnings as errors
    
    # Skip tests - Jest has ESM issues with axios in CI
    # - name: Test frontend
    #   run: npm run test --workspace=apps/frontend
    #   env:
    #     CI: true

  # ICP build commented out - requires deployment to network, not just build
  # icp:
  #   runs-on: ubuntu-latest
  #   
  #   steps:
  #   - uses: actions/checkout@v4
  #   
  #   - name: Setup Node.js
  #     uses: actions/setup-node@v4
  #     with:
  #       node-version: ${{ env.NODE_VERSION }}
  #       cache: 'npm'
  #   
  #   - name: Install DFX
  #     uses: dfinity/setup-dfx@main
  #   
  #   - name: Install dependencies
  #     run: npm ci
  #   
  #   - name: Build ICP
  #     working-directory: ./apps/icp
  #     run: |
  #       dfx start --background --clean
  #       npm run build

  # Deploy infrastructure only after all builds pass
  deploy-infrastructure:
    name: Deploy Infrastructure
    needs: [backend, frontend]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: production
    permissions:
      id-token: write   # Required for OIDC
      contents: read    # Required to checkout code
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: infrastructure/package-lock.json
    
    - name: Configure AWS credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN }}
        aws-region: ${{ vars.AWS_REGION }}
        role-session-name: GitHubActions-Infrastructure
    
    - name: Install CDK dependencies
      working-directory: ./infrastructure
      run: npm ci
    
    - name: Build CDK
      working-directory: ./infrastructure
      run: npm run build
    
    - name: CDK Diff
      working-directory: ./infrastructure
      run: npm run diff
      env:
        MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
        MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
        FRONTEND_BUCKET_NAME: ${{ vars.FRONTEND_BUCKET_NAME }}
        ASSETS_BUCKET_NAME: ${{ vars.ASSETS_BUCKET_NAME }}
    
    - name: CDK Deploy
      id: cdk-deploy
      working-directory: ./infrastructure
      run: |
        set -x  # Enable verbose output
        npm run deploy -- --require-approval never --verbose 2>&1 | tee deploy.log
        
        # Extract outputs from CDK deployment
        EC2_IP=$(grep -o 'EC2PublicIP = [0-9.]*' deploy.log | cut -d' ' -f3)
        CLOUDFRONT_URL=$(grep -o 'CloudFrontURL = https://[^[:space:]]*' deploy.log | cut -d' ' -f3)
        DISTRIBUTION_ID=$(grep -o 'CloudFrontDistributionId = [^[:space:]]*' deploy.log | cut -d' ' -f3)
        BACKEND_URL=$(grep -o 'BackendURL = https://[^[:space:]]*' deploy.log | cut -d' ' -f3)
        
        echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
        echo "cloudfront_url=$CLOUDFRONT_URL" >> $GITHUB_OUTPUT
        echo "distribution_id=$DISTRIBUTION_ID" >> $GITHUB_OUTPUT
        echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT
      env:
        MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
        MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
        FRONTEND_BUCKET_NAME: ${{ vars.FRONTEND_BUCKET_NAME }}
        ASSETS_BUCKET_NAME: ${{ vars.ASSETS_BUCKET_NAME }}
    
    - name: Generate Deployment Summary
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        # ðŸš€ Treff Application Deployed Successfully!
        
        ## ðŸ“ Application Endpoints
        
        | Service | URL |
        |---------|-----|
        | ðŸŒ **Frontend** | ${{ steps.cdk-deploy.outputs.cloudfront_url }} |
        | ðŸ”Œ **Backend API** | ${{ steps.cdk-deploy.outputs.backend_url }} |
        
        ## ðŸ–¥ï¸ Server Access
        
        **EC2 Instance IP:** `${{ steps.cdk-deploy.outputs.ec2_ip }}`
        
        **SSH Command:**
        ```bash
        ssh -i ~/.ssh/your-key.pem ubuntu@${{ steps.cdk-deploy.outputs.ec2_ip }}
        ```
        
        > âš ï¸ **Note:** Replace `your-key.pem` with your actual EC2 key pair name.
        
        ## ðŸ“¦ Resources
        
        - **CloudFront Distribution ID:** `${{ steps.cdk-deploy.outputs.distribution_id }}`
        - **Frontend Bucket:** `${{ vars.FRONTEND_BUCKET_NAME }}`
        - **Assets Bucket:** `${{ vars.ASSETS_BUCKET_NAME }}`
        - **Region:** `${{ vars.AWS_REGION }}`
        
        ## ðŸ” Quick Health Check
        
        Test the backend API:
        ```bash
        curl ${{ steps.cdk-deploy.outputs.backend_url }}/api/health
        ```
        
        ---
        *Deployment completed at $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
        EOF
    
    outputs:
      ec2_ip: ${{ steps.cdk-deploy.outputs.ec2_ip }}
      cloudfront_url: ${{ steps.cdk-deploy.outputs.cloudfront_url }}
      distribution_id: ${{ steps.cdk-deploy.outputs.distribution_id }}
      backend_url: ${{ steps.cdk-deploy.outputs.backend_url }}

  deploy-backend:
    name: Deploy Backend
    needs: [deploy-infrastructure]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: production
    permissions:
      id-token: write
      contents: read
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Build and Publish Backend
      working-directory: ./apps/backend/WebApi
      run: |
        dotnet publish -c Release -o ./publish
        cd publish
        tar -czf backend.tar.gz *
    
    - name: Configure AWS credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN }}
        aws-region: ${{ vars.AWS_REGION }}
        role-session-name: GitHubActions-Backend
    
    - name: Get EC2 Instance ID
      id: get-instance
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=TreffInfrastructureStack/TreffEC2Instance" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text)
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
    
    - name: Upload Backend to S3 (temporary storage)
      working-directory: ./apps/backend/WebApi/publish
      run: |
        aws s3 cp backend.tar.gz s3://${{ vars.DEPLOYMENT_BUCKET_NAME }}/backend.tar.gz
    
    - name: Deploy Backend to EC2 via SSM
      env:
        MYSQL_ROOT_PASS: ${{ secrets.MYSQL_ROOT_PASSWORD }}
        MYSQL_USER_PASS: ${{ secrets.MYSQL_PASSWORD }}
      run: |
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ steps.get-instance.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "echo Checking MySQL installation...",
            "if ! command -v mysql &> /dev/null; then",
            "  echo Installing MySQL...",
            "  sudo apt-get update -qq",
            "  sudo DEBIAN_FRONTEND=noninteractive apt-get install -y mysql-server",
            "fi",
            "echo Stopping any running MySQL processes...",
            "sudo systemctl stop mysql 2>/dev/null || true",
            "sleep 2",
            "sudo pkill -9 mysqld 2>/dev/null || true",
            "sleep 2",
            "echo Cleaning up MySQL lock files...",
            "sudo rm -f /var/lib/mysql/*.pid 2>/dev/null || true",
            "sudo rm -f /var/run/mysqld/*.pid 2>/dev/null || true",
            "sudo rm -f /var/run/mysqld/mysqld.sock 2>/dev/null || true",
            "sudo rm -f /var/run/mysqld/mysqld.sock.lock 2>/dev/null || true",
            "echo Creating run directory...",
            "sudo mkdir -p /var/run/mysqld",
            "sudo chown mysql:mysql /var/run/mysqld",
            "echo Starting MySQL...",
            "sudo systemctl start mysql",
            "sleep 10",
            "echo Checking MySQL status...",
            "sudo systemctl status mysql --no-pager || echo MySQL not active yet",
            "echo Waiting for MySQL to be ready...",
            "for i in {1..30}; do",
            "  if sudo systemctl is-active --quiet mysql && sudo mysql -e '\''SELECT 1'\'' &>/dev/null; then",
            "    echo MySQL is ready",
            "    break",
            "  fi",
            "  echo Waiting... \\$i/30",
            "  sleep 2",
            "done",
            "echo Running mysql_secure_installation...",
            "sudo mysql_secure_installation <<SECURE_EOF",
            "",
            "y",
            "${{ secrets.MYSQL_ROOT_PASSWORD }}",
            "${{ secrets.MYSQL_ROOT_PASSWORD }}",
            "y",
            "y",
            "y",
            "y",
            "SECURE_EOF",
            "echo Setting up database...",
            "mysql -u root -p'\''${{ secrets.MYSQL_ROOT_PASSWORD }}'\'' <<'\''EOSQL'\''",
            "CREATE DATABASE IF NOT EXISTS treff_v2;",
            "FLUSH PRIVILEGES;",
            "EOSQL",
            "echo MySQL configured successfully",
            "echo Installing .NET runtime if not present...",
            "if [ ! -f /opt/dotnet/dotnet ]; then",
            "  sudo mkdir -p /opt/dotnet",
            "  wget https://dot.net/v1/dotnet-install.sh -O /tmp/dotnet-install.sh",
            "  chmod +x /tmp/dotnet-install.sh",
            "  sudo /tmp/dotnet-install.sh --channel 9.0 --runtime aspnetcore --install-dir /opt/dotnet",
            "  sudo /tmp/dotnet-install.sh --channel 9.0 --runtime dotnet --install-dir /opt/dotnet",
            "  sudo chmod -R 755 /opt/dotnet",
            "  rm /tmp/dotnet-install.sh",
            "fi",
            "echo Updating systemd service...",
            "cat > /tmp/treff-backend.service <<'\''SERVICEEOF'\''",
            "[Unit]",
            "Description=Treff .NET Backend",
            "After=network.target mysql.service",
            "",
            "[Service]",
            "Type=simple",
            "WorkingDirectory=/var/www/treff-backend",
            "ExecStart=/opt/dotnet/dotnet /var/www/treff-backend/WebApi.dll",
            "Restart=always",
            "RestartSec=10",
            "KillSignal=SIGINT",
            "SyslogIdentifier=treff-backend",
            "User=www-data",
            "Environment=ASPNETCORE_ENVIRONMENT=Production",
            "Environment=DOTNET_ROOT=/opt/dotnet",
            "Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/dotnet",
            "SERVICEEOF",
            "echo '\''Environment=ConnectionStrings__DefaultConnection=Server=localhost;Database=treff_v2;Uid=root;Pwd=${{ secrets.MYSQL_ROOT_PASSWORD }};'\'' >> /tmp/treff-backend.service",
            "cat >> /tmp/treff-backend.service <<'\''SERVICEEOF2'\''",
            "TimeoutStartSec=30",
            "",
            "[Install]",
            "WantedBy=multi-user.target",
            "SERVICEEOF2",
            "sudo mv /tmp/treff-backend.service /etc/systemd/system/treff-backend.service",
            "sudo systemctl daemon-reload",
            "echo Downloading backend from S3...",
            "aws s3 cp s3://${{ vars.DEPLOYMENT_BUCKET_NAME }}/backend.tar.gz /tmp/backend.tar.gz",
            "echo Stopping backend service...",
            "sudo systemctl stop treff-backend || true",
            "echo Preparing directory...",
            "sudo mkdir -p /var/www/treff-backend",
            "sudo rm -rf /var/www/treff-backend/*",
            "echo Extracting new backend...",
            "sudo tar -xzf /tmp/backend.tar.gz -C /var/www/treff-backend/",
            "sudo chown -R www-data:www-data /var/www/treff-backend/",
            "echo Verifying MySQL is running...",
            "if ! sudo systemctl is-active --quiet mysql; then",
            "  echo MySQL is not running, starting it...",
            "  sudo systemctl start mysql",
            "fi",
            "echo Waiting for MySQL to be fully active...",
            "for i in {1..30}; do",
            "  if sudo systemctl is-active --quiet mysql; then",
            "    echo MySQL is active",
            "    break",
            "  fi",
            "  echo Waiting for MySQL... \\$i/30",
            "  sleep 2",
            "done",
            "sudo systemctl status mysql --no-pager | head -10",
            "echo Starting backend service...",
            "sudo systemctl enable treff-backend",
            "sudo systemctl restart treff-backend",
            "sleep 5",
            "echo Verifying backend is running...",
            "if ! sudo systemctl is-active --quiet treff-backend; then",
            "  echo Backend failed to start, checking logs...",
            "  sudo journalctl -u treff-backend -n 30 --no-pager",
            "  exit 1",
            "fi",
            "echo Service status:",
            "sudo systemctl status treff-backend --no-pager || true",
            "echo",
            "echo Testing backend locally...",
            "curl -s http://localhost:5000/api/v1/Product 2>&1 | head -20 || echo API test failed",
            "echo",
            "echo Recent logs:",
            "sudo journalctl -u treff-backend -n 30 --no-pager || true",
            "rm /tmp/backend.tar.gz",
            "echo Backend deployment complete!"
          ]' \
          --output text \
          --query 'Command.CommandId')
        
        echo "SSM Command ID: $COMMAND_ID"
        echo "Waiting for deployment to complete..."
        
        # Wait for command to complete (max 5 minutes)
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ steps.get-instance.outputs.instance_id }} \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          echo "Status: $STATUS"
          
          if [ "$STATUS" = "Success" ]; then
            echo "âœ… Backend deployed successfully!"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id ${{ steps.get-instance.outputs.instance_id }} \
              --query 'StandardOutputContent' \
              --output text
            break
          elif [ "$STATUS" = "Failed" ]; then
            echo "âŒ Backend deployment failed!"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id ${{ steps.get-instance.outputs.instance_id }} \
              --query '[StandardOutputContent,StandardErrorContent]' \
              --output text
            exit 1
          fi
          
          sleep 5
        done

  deploy-frontend:
    name: Deploy Frontend
    needs: [deploy-infrastructure]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: production
    permissions:
      id-token: write
      contents: read
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build Frontend
      working-directory: ./apps/frontend
      run: npm run build
      env:
        CI: false  # Don't treat warnings as errors
        REACT_APP_API_URL: ${{ vars.BACKEND_API_URL }}
        REACT_APP_SIGNALR_URL: ${{ vars.BACKEND_API_URL }}
    
    - name: Configure AWS credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN }}
        aws-region: ${{ vars.AWS_REGION }}
        role-session-name: GitHubActions-Frontend
    
    - name: Deploy to S3
      working-directory: ./apps/frontend/build
      run: |
        aws s3 sync . s3://${{ vars.FRONTEND_BUCKET_NAME }}/ --delete
    
    - name: Invalidate CloudFront Cache
      run: |
        aws cloudfront create-invalidation \
          --distribution-id ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }} \
          --paths "/*"
  
  # ICP deployment commented out - requires mainnet credentials and cycles
  # deploy-icp:
  #   needs: [icp]
  #   if: github.ref == 'refs/heads/main' && github.event_name == 'push'
  #   runs-on: ubuntu-latest
  #   environment: production
  #   
  #   steps:
  #   - uses: actions/checkout@v4
  #   
  #   - name: Setup Node.js
  #     uses: actions/setup-node@v4
  #     with:
  #       node-version: ${{ env.NODE_VERSION }}
  #       cache: 'npm'
  #   
  #   - name: Install DFX
  #     uses: dfinity/setup-dfx@main
  #   
  #   - name: Install dependencies
  #     run: npm ci
  #   
  #   - name: Deploy ICP to Mainnet
  #     working-directory: ./apps/icp
  #     run: |
  #       echo "${{ secrets.DFX_IDENTITY }}" > identity.pem
  #       dfx identity import github-actions identity.pem
  #       dfx identity use github-actions
  #       dfx deploy --network ic
  #     env:
  #       DFX_IDENTITY: ${{ secrets.DFX_IDENTITY }}